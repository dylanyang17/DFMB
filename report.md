## debug

注意行列索引定义不同!!!

## 液滴的处理

(!!!!!!!注意初始化，可写在reset中)

首先要定义一个数组 nowDrop[][]，表示某个格子当前的液滴标号（标号从1开始），为0表示没有液滴。再定义一个颜色QList\<\> dropColor，用于给出每个标号液滴的颜色。另外还要定义QMap\<int,bool\> histDrop[][]，用于标记每个格子被哪些液滴经过。

dropCnt 表示至今出现过的液滴种类数。

## 指令的处理

首先通过文件读入，认为每一行有一个指令。用一个结构体来表示指令，opt表示指令类型，arg[0]~arg[5]为6个参数。

opt值对应的指令为，Move为1，Split为2，Merge为3，Input为4，Output为5，而Mix拆分为若干Move进行处理。

具体参数如下：

```
args:          0  1  2  3  4  5
Move(opt==1):   x1,y1,x2,y2       (从1移动至2)
Split(opt==2):  x1,y1,x2,y2,x3,y3 (由1分成2、3)
Merge(opt==3):  x1,y1,x2,y2       (将1、2合并到中间位置)
Input(opt==4):  x1,y1             (输入到1位置)
Output(opt==5): x1,y1             (由1位置输出)
【新增虚拟opt==6表示分裂的第二阶段，opt==7表示合并的第二阶段】
```

注意在t时刻的操作，将在t+1时刻被观测到。

### 执行指令和撤销指令

按照类似栈的思路来做，如何一步一步执行的，就如何一步一步逆过来撤销。所以需要规定清楚顺序，例如在Split时严格按照指令顺序先生成x2,y2再生成x3,y3。

### Split和Merge

这两个指令跨了两个时刻，所以需要小心处理。

加入两个数组：bool notAlone[][] 来标记不单独画出某个格子的水滴；QPoint midState[][] 来标记中间结点，第一个参数为1表示正在分裂，为2表示正在合并，第二个参数为0表示非中间结点，为1表示水平中间结点，2表示垂直中间结点。

处于中间态时，在两侧放上nowDrop，但是设定notAlone[][]来不单独画出这两个水滴，另外在中间加上midState[][]状态。


## 加分项

### 关于颜色

为了颜色的丰富性，对于单滴液滴，都是通过随机来产生颜色的。不过为了美观，在分裂和合并时，采用RGB运算来得到合适的颜色。

在合并时比较简单，直接计算原来两颜色的中间值来生成新的颜色；而在分裂时通过随机一个步长step，将rgb三个中间值各自分裂成两个值，再随机分配给新的颜色。

另外当然为了更加严谨，在进行“上一步”回退之后，再“下一步”生成的液滴颜色并不会再次改变。

### 自动配置

**依据输入文档，自动进行长、宽以及输入、输出的配置**，可以非常方便，并且自动检测了其中输入、输出端口是否出现问题。

实现时通过判断能否通过边界端口支持该文档中的Input和Output，并且判断输出端口是否唯一。而长宽通过分别取指令中长宽的最大值来定。
